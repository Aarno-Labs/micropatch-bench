//------------------------------------------------------------------------------
// Standard type definitions
//------------------------------------------------------------------------------

typedef _Bool bool;
typedef unsigned char __uint8_t;
typedef __uint8_t  uint8_t;
typedef char __int8_t;
typedef __int8_t  int8_t;
typedef unsigned short __uint16_t;
typedef __uint16_t  uint16_t;
typedef short __int16_t;
typedef __int16_t  int16_t;
typedef unsigned int __uint32_t;
typedef __uint32_t  uint32_t;
typedef int __int32_t;
typedef __int32_t  int32_t;
typedef long long unsigned int __uint64_t;
typedef __uint64_t uint64_t;
typedef long long int __int64_t;
typedef __int64_t int64_t;

typedef uint32_t __size_t;
typedef __size_t size_t;
typedef int32_t __ssize_t;
typedef __ssize_t ssize_t;

// We found this type on Target 1 of the Nov 2023 AMP Hackathon
typedef long double float128;
typedef uint32_t wchar_t;
typedef uint32_t wint_t;
// Found this type on Contec annotated with STR's output
typedef wchar_t wchar_t_;

typedef void* uintptr_t;

//------------------------------------------------------------------------------
// Types for /home/ricardo/code/aarno/amp/micropatch-bench/benchmarks/cwebp-0.3.1-mtpaint/build/arm/original/cwebp.bndb
//
// This header file generated by Binary Ninja 4.2.6028-dev
//------------------------------------------------------------------------------

#ifndef BN_TYPE_PARSER

#define __packed
#define __noreturn
#define __convention(name)
#define __syscall(number)
#define __offset(...)
#define __padding
#define __named(name)
#define __inherited
#define __base(name, offset)
#define __ptr_offset(offset)
#define __data_var_refs
#define __vtable
#define __based(...)
typedef uint16_t wchar16;
typedef uint32_t wchar32;
#endif

//------------------------------------------------------------------------------
// Forward Declarations of Structures
//------------------------------------------------------------------------------

struct Elf32_Dyn;
struct Elf32_Header;
struct Elf32_Ident;
struct Elf32_ProgramHeader;
struct Elf32_Rel;
struct Elf32_SectionHeader;
struct Elf32_Sym;
struct ICCPSegment;
struct JHUFF_TBL;
struct JQUANT_TBL;
struct Metadata;
struct MetadataPayload;
struct WebPAuxStats;
struct WebPAuxStats_1;
struct WebPConfig;
struct WebPConfig_1;
struct WebPMemoryWriter;
struct WebPMemoryWriter_1;
struct WebPPicture;
struct WebPPicture_1;
struct _IO_FILE;
struct _IO_FILE_1;
struct _IO_FILE_2;
struct _IO_marker;
struct __jmp_buf_tag;
struct __sigset_t;
struct jmp_buf_s;
struct jpeg_color_deconverter;
struct jpeg_color_quantizer;
struct jpeg_common_struct;
struct jpeg_component_info;
struct jpeg_d_coef_controller;
struct jpeg_d_main_controller;
struct jpeg_d_post_controller;
struct jpeg_decomp_master;
struct jpeg_decompress_struct;
struct jpeg_decompress_struct_1;
struct jpeg_entropy_decoder;
struct jpeg_error_mgr;
struct jpeg_error_mgr_1;
struct jpeg_input_controller;
struct jpeg_inverse_dct;
struct jpeg_marker_reader;
struct jpeg_marker_struct;
struct jpeg_marker_struct_1;
struct jpeg_memory_mgr;
struct jpeg_memory_mgr_1;
struct jpeg_progress_mgr;
struct jpeg_progress_mgr_1;
struct jpeg_source_mgr;
struct jpeg_source_mgr_1;
struct jpeg_upsampler;
struct my_error_mgr;
struct timeval;
struct timeval_1;
struct timezone;
struct timezone_1;
//------------------------------------------------------------------------------
// Type Definitions
//------------------------------------------------------------------------------

// "InputFileFormat"
enum InputFileFormat
{
	PNG_ = 0x0,
	JPEG_ = 0x1,
	TIFF_ = 0x2,
	UNSUPPORTED = 0x3
};

// "J_COLOR_SPACE"
enum J_COLOR_SPACE
{
	J_COLOR_SPACE_JCS_UNKNOWN = 0x0,
	J_COLOR_SPACE_JCS_GRAYSCALE = 0x1,
	J_COLOR_SPACE_JCS_RGB = 0x2,
	J_COLOR_SPACE_JCS_YCbCr = 0x3,
	J_COLOR_SPACE_JCS_CMYK = 0x4,
	J_COLOR_SPACE_JCS_YCCK = 0x5
};

// "J_DCT_METHOD"
enum J_DCT_METHOD
{
	J_DCT_METHOD_JDCT_ISLOW = 0x0,
	J_DCT_METHOD_JDCT_IFAST = 0x1,
	J_DCT_METHOD_JDCT_FLOAT = 0x2
};

// "J_DITHER_MODE"
enum J_DITHER_MODE
{
	J_DITHER_MODE_JDITHER_NONE = 0x0,
	J_DITHER_MODE_JDITHER_ORDERED = 0x1,
	J_DITHER_MODE_JDITHER_FS = 0x2
};

// "WebPEncCSP"
enum WebPEncCSP
{
	WebPEncCSP_WEBP_YUV420 = 0x0,
	WebPEncCSP_WEBP_YUV422 = 0x1,
	WebPEncCSP_WEBP_YUV444 = 0x2,
	WebPEncCSP_WEBP_YUV400 = 0x3,
	WebPEncCSP_WEBP_CSP_UV_MASK = 0x3,
	WebPEncCSP_WEBP_YUV420A = 0x4,
	WebPEncCSP_WEBP_YUV422A = 0x5,
	WebPEncCSP_WEBP_YUV444A = 0x6,
	WebPEncCSP_WEBP_YUV400A = 0x7,
	WebPEncCSP_WEBP_CSP_ALPHA_BIT = 0x4
};

// "WebPEncodingError"
enum WebPEncodingError
{
	WebPEncodingError_VP8_ENC_OK = 0x0,
	WebPEncodingError_VP8_ENC_ERROR_OUT_OF_MEMORY = 0x1,
	WebPEncodingError_VP8_ENC_ERROR_BITSTREAM_OUT_OF_MEMORY = 0x2,
	WebPEncodingError_VP8_ENC_ERROR_NULL_PARAMETER = 0x3,
	WebPEncodingError_VP8_ENC_ERROR_INVALID_CONFIGURATION = 0x4,
	WebPEncodingError_VP8_ENC_ERROR_BAD_DIMENSION = 0x5,
	WebPEncodingError_VP8_ENC_ERROR_PARTITION0_OVERFLOW = 0x6,
	WebPEncodingError_VP8_ENC_ERROR_PARTITION_OVERFLOW = 0x7,
	WebPEncodingError_VP8_ENC_ERROR_BAD_WRITE = 0x8,
	WebPEncodingError_VP8_ENC_ERROR_FILE_TOO_BIG = 0x9,
	WebPEncodingError_VP8_ENC_ERROR_USER_ABORT = 0xa,
	WebPEncodingError_VP8_ENC_ERROR_LAST = 0xb
};

// "WebPImageHint"
enum WebPImageHint
{
	WebPImageHint_WEBP_HINT_DEFAULT = 0x0,
	WebPImageHint_WEBP_HINT_PICTURE = 0x1,
	WebPImageHint_WEBP_HINT_PHOTO = 0x2,
	WebPImageHint_WEBP_HINT_GRAPH = 0x3,
	WebPImageHint_WEBP_HINT_LAST = 0x4
};

// "WebPPreset"
enum WebPPreset
{
	WEBP_PRESET_DEFAULT = 0x0,
	WEBP_PRESET_PICTURE = 0x1,
	WEBP_PRESET_PHOTO = 0x2,
	WEBP_PRESET_DRAWING = 0x3,
	WEBP_PRESET_ICON = 0x4,
	WEBP_PRESET_TEXT = 0x5
};

// "e_dyn_tag"
enum e_dyn_tag
{
	DT_NULL = 0x0,
	DT_NEEDED = 0x1,
	DT_PLTRELSZ = 0x2,
	DT_PLTGOT = 0x3,
	DT_HASH = 0x4,
	DT_STRTAB = 0x5,
	DT_SYMTAB = 0x6,
	DT_RELA = 0x7,
	DT_RELASZ = 0x8,
	DT_RELAENT = 0x9,
	DT_STRSZ = 0xa,
	DT_SYMENT = 0xb,
	DT_INIT = 0xc,
	DT_FINI = 0xd,
	DT_SONAME = 0xe,
	DT_RPATH = 0xf,
	DT_SYMBOLIC = 0x10,
	DT_REL = 0x11,
	DT_RELSZ = 0x12,
	DT_RELENT = 0x13,
	DT_PLTREL = 0x14,
	DT_DEBUG = 0x15,
	DT_TEXTREL = 0x16,
	DT_JMPREL = 0x17,
	DT_BIND_NOW = 0x18,
	DT_INIT_ARRAY = 0x19,
	DT_FINI_ARRAY = 0x1a,
	DT_INIT_ARRAYSZ = 0x1b,
	DT_FINI_ARRAYSZ = 0x1c,
	DT_RUNPATH = 0x1d,
	DT_FLAGS = 0x1e,
	DT_ENCODING = 0x1f,
	DT_PREINIT_ARRAY = 0x20,
	DT_PREINIT_ARRAYSZ = 0x21,
	DT_LOOS = 0x6000000d,
	DT_SUNW_RTLDINF = 0x6000000e,
	DT_HIOS = 0x6ffff000,
	DT_VALRNGLO = 0x6ffffd00,
	DT_CHECKSUM = 0x6ffffdf8,
	DT_PLTPADSZ = 0x6ffffdf9,
	DT_MOVEENT = 0x6ffffdfa,
	DT_MOVESZ = 0x6ffffdfb,
	DT_FEATURE_1 = 0x6ffffdfc,
	DT_POSFLAG_1 = 0x6ffffdfd,
	DT_SYMINSZ = 0x6ffffdfe,
	DT_SYMINENT = 0x6ffffdff,
	DT_VALRNGHI = 0x6ffffdff,
	DT_ADDRRNGLO = 0x6ffffe00,
	DT_GNU_HASH = 0x6ffffef5,
	DT_CONFIG = 0x6ffffefa,
	DT_DEPAUDIT = 0x6ffffefb,
	DT_AUDIT = 0x6ffffefc,
	DT_PLTPAD = 0x6ffffefd,
	DT_MOVETAB = 0x6ffffefe,
	DT_SYMINFO = 0x6ffffeff,
	DT_ADDRRNGHI = 0x6ffffeff,
	DT_RELACOUNT = 0x6ffffff9,
	DT_RELCOUNT = 0x6ffffffa,
	DT_FLAGS_1 = 0x6ffffffb,
	DT_VERDEF = 0x6ffffffc,
	DT_VERDEFNUM = 0x6ffffffd,
	DT_VERNEED = 0x6ffffffe,
	DT_VERNEEDNUM = 0x6fffffff,
	DT_VERSYM = 0x6ffffff0,
	DT_MIPS_RLD_VERSION = 0x70000001,
	DT_MIPS_TIME_STAMP = 0x70000002,
	DT_MIPS_ICHECKSUM = 0x70000003,
	DT_MIPS_IVERSION = 0x70000004,
	DT_MIPS_FLAGS = 0x70000005,
	DT_MIPS_BASE_ADDRESS = 0x70000006,
	DT_MIPS_CONFLICT = 0x70000008,
	DT_MIPS_LIBLIST = 0x70000009,
	DT_MIPS_LOCAL_GOTNO = 0x7000000a,
	DT_MIPS_CONFLICTNO = 0x7000000b,
	DT_MIPS_LIBLISTNO = 0x70000010,
	DT_MIPS_SYMTABNO = 0x70000011,
	DT_MIPS_UNREFEXTNO = 0x70000012,
	DT_MIPS_GOTSYM = 0x70000013,
	DT_MIPS_HIPAGENO = 0x70000014,
	DT_MIPS_RLD_MAP = 0x70000016,
	DT_MIPS_RLD_MAP_REL = 0x70000035
};

// "e_machine"
enum e_machine
{
	EM_NONE = 0x0,
	EM_M32 = 0x1,
	EM_SPARC = 0x2,
	EM_386 = 0x3,
	EM_68K = 0x4,
	EM_88K = 0x5,
	EM_860 = 0x7,
	EM_MIPS = 0x8,
	EM_S370 = 0x9,
	EM_MIPS_RS3_LE = 0xa,
	EM_PARISC = 0xf,
	EM_VPP500 = 0x11,
	EM_SPARC32PLUS = 0x12,
	EM_960 = 0x13,
	EM_PPC = 0x14,
	EM_PPC64 = 0x15,
	EM_S390 = 0x16,
	EM_V800 = 0x24,
	EM_FR20 = 0x25,
	EM_RH32 = 0x26,
	EM_RCE = 0x27,
	EM_ARM = 0x28,
	EM_FAKE_ALPHA = 0x29,
	EM_SH = 0x2a,
	EM_SPARCV9 = 0x2b,
	EM_TRICORE = 0x2c,
	EM_ARC = 0x2d,
	EM_H8_300 = 0x2e,
	EM_H8_300H = 0x2f,
	EM_H8S = 0x30,
	EM_H8_500 = 0x31,
	EM_IA_64 = 0x32,
	EM_MIPS_X = 0x33,
	EM_COLDFIRE = 0x34,
	EM_68HC12 = 0x35,
	EM_MMA = 0x36,
	EM_PCP = 0x37,
	EM_NCPU = 0x38,
	EM_NDR1 = 0x39,
	EM_STARCORE = 0x3a,
	EM_ME16 = 0x3b,
	EM_ST100 = 0x3c,
	EM_TINYJ = 0x3d,
	EM_X86_64 = 0x3e,
	EM_PDSP = 0x3f,
	EM_FX66 = 0x42,
	EM_ST9PLUS = 0x43,
	EM_ST7 = 0x44,
	EM_68HC16 = 0x45,
	EM_68HC11 = 0x46,
	EM_68HC08 = 0x47,
	EM_68HC05 = 0x48,
	EM_SVX = 0x49,
	EM_ST19 = 0x4a,
	EM_VAX = 0x4b,
	EM_CRIS = 0x4c,
	EM_JAVELIN = 0x4d,
	EM_FIREPATH = 0x4e,
	EM_ZSP = 0x4f,
	EM_MMIX = 0x50,
	EM_HUANY = 0x51,
	EM_PRISM = 0x52,
	EM_AVR = 0x53,
	EM_FR30 = 0x54,
	EM_D10V = 0x55,
	EM_D30V = 0x56,
	EM_V850 = 0x57,
	EM_M32R = 0x58,
	EM_MN10300 = 0x59,
	EM_MN10200 = 0x5a,
	EM_PJ = 0x5b,
	EM_OPENRISC = 0x5c,
	EM_ARC_A5 = 0x5d,
	EM_XTENSA = 0x5e,
	EM_ALTERA_NIOS2 = 0x71,
	EM_AARCH64 = 0xb7,
	EM_TILEPRO = 0xbc,
	EM_MICROBLAZE = 0xbd,
	EM_TILEGX = 0xbf,
	EM_NUM = 0xc0
};

// "e_type"
enum e_type
{
	ET_NONE = 0x0,
	ET_REL = 0x1,
	ET_EXEC = 0x2,
	ET_DYN = 0x3,
	ET_CORE = 0x4,
	ET_NUM = 0x5
};

// "p_flags"
enum p_flags
{
	PF_X = 0x1,
	PF_W = 0x2,
	PF_R = 0x4
};

// "p_type"
enum p_type
{
	PT_NULL = 0x0,
	PT_LOAD = 0x1,
	PT_DYNAMIC = 0x2,
	PT_INTERP = 0x3,
	PT_NOTE = 0x4,
	PT_SHLIB = 0x5,
	PT_PHDR = 0x6,
	PT_TLS = 0x7,
	PT_NUM = 0x8,
	PT_LOOS = 0x60000000,
	PT_GNU_EH_FRAME = 0x6474e550,
	PT_GNU_STACK = 0x6474e551,
	PT_GNU_RELRO = 0x6474e552,
	PT_GNU_PROPERTY = 0x6474e553,
	PT_LOSUNW = 0x6ffffffa,
	PT_SUNWBSS = 0x6ffffffb,
	PT_SUNWSTACK = 0x6ffffffa,
	PT_MIPS_REGINFO = 0x70000000,
	PT_MIPS_RTPROC = 0x70000001,
	PT_MIPS_OPTIONS = 0x70000002,
	PT_MIPS_ABIFLAGS = 0x70000003
};

// "sh_flags"
enum sh_flags
{
	SHF_WRITE = 0x1,
	SHF_ALLOC = 0x2,
	SHF_EXECINSTR = 0x4,
	SHF_MERGE = 0x10,
	SHF_STRINGS = 0x20,
	SHF_INFO_LINK = 0x40,
	SHF_LINK_ORDER = 0x80,
	SHF_OS_NONCONFORMING = 0x100,
	SHF_GROUP = 0x200,
	SHF_TLS = 0x400,
	SHF_COMPRESSED = 0x800,
	SHF_MASKOS = 0xff00000,
	SHF_ENTRYSECT = 0x10000000,
	SHF_COMDEF = 0x80000000
};

// "sh_type"
enum sh_type
{
	SHT_NULL = 0x0,
	SHT_PROGBITS = 0x1,
	SHT_SYMTAB = 0x2,
	SHT_STRTAB = 0x3,
	SHT_RELA = 0x4,
	SHT_HASH = 0x5,
	SHT_DYNAMIC = 0x6,
	SHT_NOTE = 0x7,
	SHT_NOBITS = 0x8,
	SHT_REL = 0x9,
	SHT_SHLIB = 0xa,
	SHT_DYNSYM = 0xb,
	SHT_LOUSER = 0x80000000,
	SHT_HIUSER = 0xffffffff,
	SHT_LOPROC = 0x70000000,
	SHT_HIPROC = 0x7fffffff
};

// "Elf32_Rel"
struct Elf32_Rel
{
	uint32_t r_offset;
	uint32_t r_info;
};

// "Elf32_Sym"
struct Elf32_Sym
{
	uint32_t st_name;
	uint32_t st_value;
	uint32_t st_size;
	uint8_t st_info;
	uint8_t st_other;
	uint16_t st_shndx;
};

// "ICCPSegment"
struct ICCPSegment __packed
{
	unsigned char const* data;
	unsigned int data_length;
	int seq;
};

// "JBLOCK"
typedef short int JBLOCK[0x40];

// "JBLOCKARRAY"
typedef short int (** JBLOCKARRAY)[0x40];

// "JBLOCKROW"
typedef short int (* JBLOCKROW)[0x40];

// "JCOEF"
typedef short int JCOEF;

// "JDIMENSION"
typedef unsigned int JDIMENSION;

// "JHUFF_TBL"
struct JHUFF_TBL __packed
{
	unsigned char bits[0x11];
	unsigned char huffval[0x100];
	__padding char _111[3];
	int sent_table;
};

// "JOCTET"
typedef unsigned char JOCTET;

// "JQUANT_TBL"
struct JQUANT_TBL __packed
{
	short unsigned int quantval[0x40];
	int sent_table;
};

// "JSAMPARRAY"
typedef unsigned char** JSAMPARRAY;

// "JSAMPLE"
typedef unsigned char JSAMPLE;

// "JSAMPROW"
typedef unsigned char* JSAMPROW;

// "UINT16"
typedef short unsigned int UINT16;

// "UINT8"
typedef unsigned char UINT8;

// "WebPAuxStats"
struct WebPAuxStats __packed
{
	int coded_size;
	float PSNR[0x5];
	int block_count[0x3];
	int header_bytes[0x2];
	int residual_bytes[0x4][0x3];
	int segment_size[0x4];
	int segment_quant[0x4];
	int segment_level[0x4];
	int alpha_data_size;
	int layer_data_size;
	unsigned int lossless_features;
	int histogram_bits;
	int transform_bits;
	int cache_bits;
	int palette_size;
	int lossless_size;
	unsigned int pad[0x4];
};

// "WebPAuxStats_1"
struct WebPAuxStats_1 __packed
{
	int coded_size;
	float PSNR[0x5];
	int block_count[0x3];
	int header_bytes[0x2];
	int residual_bytes[0x4][0x3];
	int segment_size[0x4];
	int segment_quant[0x4];
	int segment_level[0x4];
	int alpha_data_size;
	int layer_data_size;
	unsigned int lossless_features;
	int histogram_bits;
	int transform_bits;
	int cache_bits;
	int palette_size;
	int lossless_size;
	unsigned int pad[0x4];
};

// "WebPConfig_image_hint"
enum WebPConfig_image_hint
{
	WebPConfig_image_hint_WEBP_HINT_DEFAULT = 0x0,
	WebPConfig_image_hint_WEBP_HINT_PICTURE = 0x1,
	WebPConfig_image_hint_WEBP_HINT_PHOTO = 0x2,
	WebPConfig_image_hint_WEBP_HINT_GRAPH = 0x3,
	WebPConfig_image_hint_WEBP_HINT_LAST = 0x4
};

// "WebPConfig"
struct WebPConfig __packed
{
	int lossless;
	float quality;
	int method;
	enum WebPConfig_image_hint image_hint;
	int target_size;
	float target_PSNR;
	int segments;
	int sns_strength;
	int filter_strength;
	int filter_sharpness;
	int filter_type;
	int autofilter;
	int alpha_compression;
	int alpha_filtering;
	int alpha_quality;
	int pass;
	int show_compressed;
	int preprocessing;
	int partitions;
	int partition_limit;
	int emulate_jpeg_size;
	int thread_level;
	int low_memory;
	unsigned int pad[0x5];
};

// "WebPConfig_1_image_hint"
enum WebPConfig_1_image_hint
{
	WebPConfig_1_image_hint_WEBP_HINT_DEFAULT = 0x0,
	WebPConfig_1_image_hint_WEBP_HINT_PICTURE = 0x1,
	WebPConfig_1_image_hint_WEBP_HINT_PHOTO = 0x2,
	WebPConfig_1_image_hint_WEBP_HINT_GRAPH = 0x3,
	WebPConfig_1_image_hint_WEBP_HINT_LAST = 0x4
};

// "WebPConfig_1"
struct WebPConfig_1 __packed
{
	int lossless;
	float quality;
	int method;
	enum WebPConfig_1_image_hint image_hint;
	int target_size;
	float target_PSNR;
	int segments;
	int sns_strength;
	int filter_strength;
	int filter_sharpness;
	int filter_type;
	int autofilter;
	int alpha_compression;
	int alpha_filtering;
	int alpha_quality;
	int pass;
	int show_compressed;
	int preprocessing;
	int partitions;
	int partition_limit;
	int emulate_jpeg_size;
	int thread_level;
	int low_memory;
	unsigned int pad[0x5];
};

// "WebPMemoryWriter"
struct WebPMemoryWriter __packed
{
	unsigned char* mem;
	unsigned int size;
	unsigned int max_size;
	unsigned int pad[0x1];
};

// "WebPMemoryWriter_1"
struct WebPMemoryWriter_1 __packed
{
	unsigned char* mem;
	unsigned int size;
	unsigned int max_size;
	unsigned int pad[0x1];
};

// "WebPPicture_colorspace"
enum WebPPicture_colorspace
{
	WebPPicture_colorspace_WEBP_YUV420 = 0x0,
	WebPPicture_colorspace_WEBP_YUV422 = 0x1,
	WebPPicture_colorspace_WEBP_YUV444 = 0x2,
	WebPPicture_colorspace_WEBP_YUV400 = 0x3,
	WebPPicture_colorspace_WEBP_CSP_UV_MASK = 0x3,
	WebPPicture_colorspace_WEBP_YUV420A = 0x4,
	WebPPicture_colorspace_WEBP_YUV422A = 0x5,
	WebPPicture_colorspace_WEBP_YUV444A = 0x6,
	WebPPicture_colorspace_WEBP_YUV400A = 0x7,
	WebPPicture_colorspace_WEBP_CSP_ALPHA_BIT = 0x4
};

// "WebPPicture_error_code"
enum WebPPicture_error_code
{
	WebPPicture_error_code_VP8_ENC_OK = 0x0,
	WebPPicture_error_code_VP8_ENC_ERROR_OUT_OF_MEMORY = 0x1,
	WebPPicture_error_code_VP8_ENC_ERROR_BITSTREAM_OUT_OF_MEMORY = 0x2,
	WebPPicture_error_code_VP8_ENC_ERROR_NULL_PARAMETER = 0x3,
	WebPPicture_error_code_VP8_ENC_ERROR_INVALID_CONFIGURATION = 0x4,
	WebPPicture_error_code_VP8_ENC_ERROR_BAD_DIMENSION = 0x5,
	WebPPicture_error_code_VP8_ENC_ERROR_PARTITION0_OVERFLOW = 0x6,
	WebPPicture_error_code_VP8_ENC_ERROR_PARTITION_OVERFLOW = 0x7,
	WebPPicture_error_code_VP8_ENC_ERROR_BAD_WRITE = 0x8,
	WebPPicture_error_code_VP8_ENC_ERROR_FILE_TOO_BIG = 0x9,
	WebPPicture_error_code_VP8_ENC_ERROR_USER_ABORT = 0xa,
	WebPPicture_error_code_VP8_ENC_ERROR_LAST = 0xb
};

// "WebPPicture"
struct WebPPicture __packed
{
	int use_argb;
	enum WebPPicture_colorspace colorspace;
	int width;
	int height;
	unsigned char* y;
	unsigned char* u;
	unsigned char* v;
	int y_stride;
	int uv_stride;
	unsigned char* a;
	int a_stride;
	unsigned int pad1[0x2];
	unsigned int* argb;
	int argb_stride;
	unsigned int pad2[0x3];
	int (* writer)();
	void* custom_ptr;
	int extra_info_type;
	unsigned char* extra_info;
	struct WebPAuxStats* stats;
	enum WebPPicture_error_code error_code;
	int (* progress_hook)();
	void* user_data;
	unsigned int pad3[0x3];
	unsigned char* u0;
	unsigned char* v0;
	int uv0_stride;
	unsigned int pad4[0x7];
	void* memory_;
	void* memory_argb_;
	void* pad5[0x2];
};

// "WebPPicture_1_colorspace"
enum WebPPicture_1_colorspace
{
	WebPPicture_1_colorspace_WEBP_YUV420 = 0x0,
	WebPPicture_1_colorspace_WEBP_YUV422 = 0x1,
	WebPPicture_1_colorspace_WEBP_YUV444 = 0x2,
	WebPPicture_1_colorspace_WEBP_YUV400 = 0x3,
	WebPPicture_1_colorspace_WEBP_CSP_UV_MASK = 0x3,
	WebPPicture_1_colorspace_WEBP_YUV420A = 0x4,
	WebPPicture_1_colorspace_WEBP_YUV422A = 0x5,
	WebPPicture_1_colorspace_WEBP_YUV444A = 0x6,
	WebPPicture_1_colorspace_WEBP_YUV400A = 0x7,
	WebPPicture_1_colorspace_WEBP_CSP_ALPHA_BIT = 0x4
};

// "WebPPicture_1_error_code"
enum WebPPicture_1_error_code
{
	WebPPicture_1_error_code_VP8_ENC_OK = 0x0,
	WebPPicture_1_error_code_VP8_ENC_ERROR_OUT_OF_MEMORY = 0x1,
	WebPPicture_1_error_code_VP8_ENC_ERROR_BITSTREAM_OUT_OF_MEMORY = 0x2,
	WebPPicture_1_error_code_VP8_ENC_ERROR_NULL_PARAMETER = 0x3,
	WebPPicture_1_error_code_VP8_ENC_ERROR_INVALID_CONFIGURATION = 0x4,
	WebPPicture_1_error_code_VP8_ENC_ERROR_BAD_DIMENSION = 0x5,
	WebPPicture_1_error_code_VP8_ENC_ERROR_PARTITION0_OVERFLOW = 0x6,
	WebPPicture_1_error_code_VP8_ENC_ERROR_PARTITION_OVERFLOW = 0x7,
	WebPPicture_1_error_code_VP8_ENC_ERROR_BAD_WRITE = 0x8,
	WebPPicture_1_error_code_VP8_ENC_ERROR_FILE_TOO_BIG = 0x9,
	WebPPicture_1_error_code_VP8_ENC_ERROR_USER_ABORT = 0xa,
	WebPPicture_1_error_code_VP8_ENC_ERROR_LAST = 0xb
};

// "WebPPicture_1"
struct WebPPicture_1 __packed
{
	int use_argb;
	enum WebPPicture_1_colorspace colorspace;
	int width;
	int height;
	unsigned char* y;
	unsigned char* u;
	unsigned char* v;
	int y_stride;
	int uv_stride;
	unsigned char* a;
	int a_stride;
	unsigned int pad1[0x2];
	unsigned int* argb;
	int argb_stride;
	unsigned int pad2[0x3];
	int (* writer)();
	void* custom_ptr;
	int extra_info_type;
	unsigned char* extra_info;
	struct WebPAuxStats_1* stats;
	enum WebPPicture_1_error_code error_code;
	int (* progress_hook)();
	void* user_data;
	unsigned int pad3[0x3];
	unsigned char* u0;
	unsigned char* v0;
	int uv0_stride;
	unsigned int pad4[0x7];
	void* memory_;
	void* memory_argb_;
	void* pad5[0x2];
};

// "WebPProgressHook"
typedef int (* WebPProgressHook)();

// "WebPWriterFunction"
typedef int (* WebPWriterFunction)();

// "_IO_marker"
struct _IO_marker __packed
{
	struct _IO_marker* _next;
	struct _IO_FILE_2* _sbuf;
	int _pos;
};

// "__compar_fn_t"
typedef int (* __compar_fn_t)();

// "__jmp_buf"
typedef int __jmp_buf[0x40];

// "__off64_t"
typedef long long int __off64_t;

// "__off_t"
typedef long int __off_t;

// "__quad_t"
typedef long long int __quad_t;

// "__sigset_t"
struct __sigset_t __packed
{
	long unsigned int __val[0x20];
};

// "__suseconds_t"
typedef long int __suseconds_t;

// "__time_t"
typedef long int __time_t;

// "boolean"
typedef int boolean;

// "j_common_ptr"
typedef struct jpeg_common_struct* j_common_ptr;

// "j_decompress_ptr"
typedef struct jpeg_decompress_struct_1* j_decompress_ptr;

// "jpeg_color_deconverter"
struct jpeg_color_deconverter __packed
{
	void (* start_pass)();
	void (* color_convert)();
};

// "jpeg_color_quantizer"
struct jpeg_color_quantizer __packed
{
	void (* start_pass)();
	void (* color_quantize)();
	void (* finish_pass)();
	void (* new_color_map)();
};

// "jpeg_common_struct"
struct jpeg_common_struct __packed
{
	struct jpeg_error_mgr_1* err;
	struct jpeg_memory_mgr_1* mem;
	struct jpeg_progress_mgr_1* progress;
	void* client_data;
	int is_decompressor;
	int global_state;
};

// "jpeg_component_info"
struct jpeg_component_info __packed
{
	int component_id;
	int component_index;
	int h_samp_factor;
	int v_samp_factor;
	int quant_tbl_no;
	int dc_tbl_no;
	int ac_tbl_no;
	unsigned int width_in_blocks;
	unsigned int height_in_blocks;
	int DCT_h_scaled_size;
	int DCT_v_scaled_size;
	unsigned int downsampled_width;
	unsigned int downsampled_height;
	int component_needed;
	int MCU_width;
	int MCU_height;
	int MCU_blocks;
	int MCU_sample_width;
	int last_col_width;
	int last_row_height;
	struct { short unsigned int quantval[0x40]; int sent_table; }* quant_table;
	void* dct_table;
};

// "jpeg_d_coef_controller"
struct jpeg_d_coef_controller __packed
{
	void (* start_input_pass)();
	int (* consume_data)();
	void (* start_output_pass)();
	int (* decompress_data)();
	void** coef_arrays;
};

// "jpeg_d_main_controller"
struct jpeg_d_main_controller __packed
{
	void (* start_pass)();
	void (* process_data)();
};

// "jpeg_d_post_controller"
struct jpeg_d_post_controller __packed
{
	void (* start_pass)();
	void (* post_process_data)();
};

// "jpeg_decomp_master"
struct jpeg_decomp_master __packed
{
	void (* prepare_for_output_pass)();
	void (* finish_output_pass)();
	int is_dummy_pass;
};

// "jpeg_decompress_struct_jpeg_color_space"
enum jpeg_decompress_struct_jpeg_color_space
{
	jpeg_decompress_struct_jpeg_color_space_JCS_UNKNOWN = 0x0,
	jpeg_decompress_struct_jpeg_color_space_JCS_GRAYSCALE = 0x1,
	jpeg_decompress_struct_jpeg_color_space_JCS_RGB = 0x2,
	jpeg_decompress_struct_jpeg_color_space_JCS_YCbCr = 0x3,
	jpeg_decompress_struct_jpeg_color_space_JCS_CMYK = 0x4,
	jpeg_decompress_struct_jpeg_color_space_JCS_YCCK = 0x5
};

// "jpeg_decompress_struct_out_color_space"
enum jpeg_decompress_struct_out_color_space
{
	jpeg_decompress_struct_out_color_space_JCS_UNKNOWN = 0x0,
	jpeg_decompress_struct_out_color_space_JCS_GRAYSCALE = 0x1,
	jpeg_decompress_struct_out_color_space_JCS_RGB = 0x2,
	jpeg_decompress_struct_out_color_space_JCS_YCbCr = 0x3,
	jpeg_decompress_struct_out_color_space_JCS_CMYK = 0x4,
	jpeg_decompress_struct_out_color_space_JCS_YCCK = 0x5
};

// "jpeg_decompress_struct_dct_method"
enum jpeg_decompress_struct_dct_method
{
	jpeg_decompress_struct_dct_method_JDCT_ISLOW = 0x0,
	jpeg_decompress_struct_dct_method_JDCT_IFAST = 0x1,
	jpeg_decompress_struct_dct_method_JDCT_FLOAT = 0x2
};

// "jpeg_decompress_struct_dither_mode"
enum jpeg_decompress_struct_dither_mode
{
	jpeg_decompress_struct_dither_mode_JDITHER_NONE = 0x0,
	jpeg_decompress_struct_dither_mode_JDITHER_ORDERED = 0x1,
	jpeg_decompress_struct_dither_mode_JDITHER_FS = 0x2
};

// "jpeg_decompress_struct"
struct jpeg_decompress_struct __packed
{
	struct jpeg_error_mgr* err;
	struct jpeg_memory_mgr* mem;
	struct jpeg_progress_mgr* progress;
	void* client_data;
	int is_decompressor;
	int global_state;
	struct jpeg_source_mgr* src;
	unsigned int image_width;
	unsigned int image_height;
	int num_components;
	enum jpeg_decompress_struct_jpeg_color_space jpeg_color_space;
	enum jpeg_decompress_struct_out_color_space out_color_space;
	unsigned int scale_num;
	unsigned int scale_denom;
	double output_gamma;
	int buffered_image;
	int raw_data_out;
	enum jpeg_decompress_struct_dct_method dct_method;
	int do_fancy_upsampling;
	int do_block_smoothing;
	int quantize_colors;
	enum jpeg_decompress_struct_dither_mode dither_mode;
	int two_pass_quantize;
	int desired_number_of_colors;
	int enable_1pass_quant;
	int enable_external_quant;
	int enable_2pass_quant;
	unsigned int output_width;
	unsigned int output_height;
	int out_color_components;
	int output_components;
	int rec_outbuf_height;
	int actual_number_of_colors;
	unsigned char** colormap;
	unsigned int output_scanline;
	int input_scan_number;
	unsigned int input_iMCU_row;
	int output_scan_number;
	unsigned int output_iMCU_row;
	int (* coef_bits)[0x40];
	struct { short unsigned int quantval[0x40]; int sent_table; }* quant_tbl_ptrs[0x4];
	struct { unsigned char bits[0x11]; unsigned char huffval[0x100]; __padding char _111[0x3];int sent_table; }* dc_huff_tbl_ptrs[0x4];
	struct { unsigned char bits[0x11]; unsigned char huffval[0x100]; __padding char _111[0x3];int sent_table; }* ac_huff_tbl_ptrs[0x4];
	int data_precision;
	struct { int component_id; int component_index; int h_samp_factor; int v_samp_factor; int quant_tbl_no; int dc_tbl_no; int ac_tbl_no; unsigned int width_in_blocks; unsigned int height_in_blocks; int DCT_h_scaled_size; int DCT_v_scaled_size; unsigned int downsampled_width; unsigned int downsampled_height; int component_needed; int MCU_width; int MCU_height; int MCU_blocks; int MCU_sample_width; int last_col_width; int last_row_height; struct { short unsigned int quantval[0x40]; int sent_table; }* quant_table; void* dct_table; }* comp_info;
	int is_baseline;
	int progressive_mode;
	int arith_code;
	unsigned char arith_dc_L[0x10];
	unsigned char arith_dc_U[0x10];
	unsigned char arith_ac_K[0x10];
	unsigned int restart_interval;
	int saw_JFIF_marker;
	unsigned char JFIF_major_version;
	unsigned char JFIF_minor_version;
	unsigned char density_unit;
	__padding char _123[1];
	short unsigned int X_density;
	short unsigned int Y_density;
	int saw_Adobe_marker;
	unsigned char Adobe_transform;
	__padding char _12D[3];
	int CCIR601_sampling;
	struct jpeg_marker_struct* marker_list;
	int max_h_samp_factor;
	int max_v_samp_factor;
	int min_DCT_h_scaled_size;
	int min_DCT_v_scaled_size;
	unsigned int total_iMCU_rows;
	unsigned char* sample_range_limit;
	int comps_in_scan;
	struct { int component_id; int component_index; int h_samp_factor; int v_samp_factor; int quant_tbl_no; int dc_tbl_no; int ac_tbl_no; unsigned int width_in_blocks; unsigned int height_in_blocks; int DCT_h_scaled_size; int DCT_v_scaled_size; unsigned int downsampled_width; unsigned int downsampled_height; int component_needed; int MCU_width; int MCU_height; int MCU_blocks; int MCU_sample_width; int last_col_width; int last_row_height; struct { short unsigned int quantval[0x40]; int sent_table; }* quant_table; void* dct_table; }* cur_comp_info[0x4];
	unsigned int MCUs_per_row;
	unsigned int MCU_rows_in_scan;
	int blocks_in_MCU;
	int MCU_membership[0xa];
	int Ss;
	int Se;
	int Ah;
	int Al;
	int block_size;
	int const* natural_order;
	int lim_Se;
	int unread_marker;
	struct jpeg_decomp_master* master;
	struct jpeg_d_main_controller* main;
	struct jpeg_d_coef_controller* coef;
	struct jpeg_d_post_controller* post;
	struct jpeg_input_controller* inputctl;
	struct jpeg_marker_reader* marker;
	struct jpeg_entropy_decoder* entropy;
	struct jpeg_inverse_dct* idct;
	struct jpeg_upsampler* upsample;
	struct jpeg_color_deconverter* cconvert;
	struct jpeg_color_quantizer* cquantize;
	__padding char _1E4[4];
};

// "jpeg_decompress_struct_1_jpeg_color_space"
enum jpeg_decompress_struct_1_jpeg_color_space
{
	jpeg_decompress_struct_1_jpeg_color_space_JCS_UNKNOWN = 0x0,
	jpeg_decompress_struct_1_jpeg_color_space_JCS_GRAYSCALE = 0x1,
	jpeg_decompress_struct_1_jpeg_color_space_JCS_RGB = 0x2,
	jpeg_decompress_struct_1_jpeg_color_space_JCS_YCbCr = 0x3,
	jpeg_decompress_struct_1_jpeg_color_space_JCS_CMYK = 0x4,
	jpeg_decompress_struct_1_jpeg_color_space_JCS_YCCK = 0x5
};

// "jpeg_decompress_struct_1_out_color_space"
enum jpeg_decompress_struct_1_out_color_space
{
	jpeg_decompress_struct_1_out_color_space_JCS_UNKNOWN = 0x0,
	jpeg_decompress_struct_1_out_color_space_JCS_GRAYSCALE = 0x1,
	jpeg_decompress_struct_1_out_color_space_JCS_RGB = 0x2,
	jpeg_decompress_struct_1_out_color_space_JCS_YCbCr = 0x3,
	jpeg_decompress_struct_1_out_color_space_JCS_CMYK = 0x4,
	jpeg_decompress_struct_1_out_color_space_JCS_YCCK = 0x5
};

// "jpeg_decompress_struct_1_dct_method"
enum jpeg_decompress_struct_1_dct_method
{
	jpeg_decompress_struct_1_dct_method_JDCT_ISLOW = 0x0,
	jpeg_decompress_struct_1_dct_method_JDCT_IFAST = 0x1,
	jpeg_decompress_struct_1_dct_method_JDCT_FLOAT = 0x2
};

// "jpeg_decompress_struct_1_dither_mode"
enum jpeg_decompress_struct_1_dither_mode
{
	jpeg_decompress_struct_1_dither_mode_JDITHER_NONE = 0x0,
	jpeg_decompress_struct_1_dither_mode_JDITHER_ORDERED = 0x1,
	jpeg_decompress_struct_1_dither_mode_JDITHER_FS = 0x2
};

// "jpeg_decompress_struct_1"
struct jpeg_decompress_struct_1 __packed
{
	struct jpeg_error_mgr_1* err;
	struct jpeg_memory_mgr_1* mem;
	struct jpeg_progress_mgr_1* progress;
	void* client_data;
	int is_decompressor;
	int global_state;
	struct jpeg_source_mgr_1* src;
	unsigned int image_width;
	unsigned int image_height;
	int num_components;
	enum jpeg_decompress_struct_1_jpeg_color_space jpeg_color_space;
	enum jpeg_decompress_struct_1_out_color_space out_color_space;
	unsigned int scale_num;
	unsigned int scale_denom;
	double output_gamma;
	int buffered_image;
	int raw_data_out;
	enum jpeg_decompress_struct_1_dct_method dct_method;
	int do_fancy_upsampling;
	int do_block_smoothing;
	int quantize_colors;
	enum jpeg_decompress_struct_1_dither_mode dither_mode;
	int two_pass_quantize;
	int desired_number_of_colors;
	int enable_1pass_quant;
	int enable_external_quant;
	int enable_2pass_quant;
	unsigned int output_width;
	unsigned int output_height;
	int out_color_components;
	int output_components;
	int rec_outbuf_height;
	int actual_number_of_colors;
	unsigned char** colormap;
	unsigned int output_scanline;
	int input_scan_number;
	unsigned int input_iMCU_row;
	int output_scan_number;
	unsigned int output_iMCU_row;
	int (* coef_bits)[0x40];
	struct { short unsigned int quantval[0x40]; int sent_table; }* quant_tbl_ptrs[0x4];
	struct { unsigned char bits[0x11]; unsigned char huffval[0x100]; __padding char _111[0x3];int sent_table; }* dc_huff_tbl_ptrs[0x4];
	struct { unsigned char bits[0x11]; unsigned char huffval[0x100]; __padding char _111[0x3];int sent_table; }* ac_huff_tbl_ptrs[0x4];
	int data_precision;
	struct { int component_id; int component_index; int h_samp_factor; int v_samp_factor; int quant_tbl_no; int dc_tbl_no; int ac_tbl_no; unsigned int width_in_blocks; unsigned int height_in_blocks; int DCT_h_scaled_size; int DCT_v_scaled_size; unsigned int downsampled_width; unsigned int downsampled_height; int component_needed; int MCU_width; int MCU_height; int MCU_blocks; int MCU_sample_width; int last_col_width; int last_row_height; struct { short unsigned int quantval[0x40]; int sent_table; }* quant_table; void* dct_table; }* comp_info;
	int is_baseline;
	int progressive_mode;
	int arith_code;
	unsigned char arith_dc_L[0x10];
	unsigned char arith_dc_U[0x10];
	unsigned char arith_ac_K[0x10];
	unsigned int restart_interval;
	int saw_JFIF_marker;
	unsigned char JFIF_major_version;
	unsigned char JFIF_minor_version;
	unsigned char density_unit;
	__padding char _123[1];
	short unsigned int X_density;
	short unsigned int Y_density;
	int saw_Adobe_marker;
	unsigned char Adobe_transform;
	__padding char _12D[3];
	int CCIR601_sampling;
	struct jpeg_marker_struct_1* marker_list;
	int max_h_samp_factor;
	int max_v_samp_factor;
	int min_DCT_h_scaled_size;
	int min_DCT_v_scaled_size;
	unsigned int total_iMCU_rows;
	unsigned char* sample_range_limit;
	int comps_in_scan;
	struct { int component_id; int component_index; int h_samp_factor; int v_samp_factor; int quant_tbl_no; int dc_tbl_no; int ac_tbl_no; unsigned int width_in_blocks; unsigned int height_in_blocks; int DCT_h_scaled_size; int DCT_v_scaled_size; unsigned int downsampled_width; unsigned int downsampled_height; int component_needed; int MCU_width; int MCU_height; int MCU_blocks; int MCU_sample_width; int last_col_width; int last_row_height; struct { short unsigned int quantval[0x40]; int sent_table; }* quant_table; void* dct_table; }* cur_comp_info[0x4];
	unsigned int MCUs_per_row;
	unsigned int MCU_rows_in_scan;
	int blocks_in_MCU;
	int MCU_membership[0xa];
	int Ss;
	int Se;
	int Ah;
	int Al;
	int block_size;
	int const* natural_order;
	int lim_Se;
	int unread_marker;
	void* master;
	void* main;
	void* coef;
	void* post;
	void* inputctl;
	void* marker;
	void* entropy;
	void* idct;
	void* upsample;
	void* cconvert;
	void* cquantize;
	__padding char _1E4[4];
};

// "jpeg_entropy_decoder"
struct jpeg_entropy_decoder __packed
{
	void (* start_pass)();
	int (* decode_mcu)();
};

// "jpeg_error_mgr"
struct jpeg_error_mgr __packed
{
	void (* error_exit)();
	void (* emit_message)();
	void (* output_message)();
	void (* format_message)();
	void (* reset_error_mgr)();
	int msg_code;
	union __packed
	{
		int i[0x8];
		char s[0x50];
	} msg_parm;
	int trace_level;
	long int num_warnings;
	char const* const* jpeg_message_table;
	int last_jpeg_message;
	char const* const* addon_message_table;
	int first_addon_message;
	int last_addon_message;
};

// "jpeg_input_controller"
struct jpeg_input_controller __packed
{
	int (* consume_input)();
	void (* reset_input_controller)();
	void (* start_input_pass)();
	void (* finish_input_pass)();
	int has_multiple_scans;
	int eoi_reached;
};

// "jpeg_inverse_dct"
struct jpeg_inverse_dct __packed
{
	void (* start_pass)();
	void (* inverse_DCT[0xa])();
};

// "jpeg_marker_reader"
struct jpeg_marker_reader __packed
{
	void (* reset_marker_reader)();
	int (* read_markers)();
	int (* read_restart_marker)();
	int saw_SOI;
	int saw_SOF;
	int next_restart_num;
	unsigned int discarded_bytes;
};

// "jpeg_marker_struct"
struct jpeg_marker_struct __packed
{
	struct jpeg_marker_struct* next;
	unsigned char marker;
	__padding char _5[3];
	unsigned int original_length;
	unsigned int data_length;
	unsigned char* data;
};

// "jpeg_marker_struct_1"
struct jpeg_marker_struct_1 __packed
{
	struct jpeg_marker_struct_1* next;
	unsigned char marker;
	__padding char _5[3];
	unsigned int original_length;
	unsigned int data_length;
	unsigned char* data;
};

// "jpeg_memory_mgr"
struct jpeg_memory_mgr __packed
{
	void* (* alloc_small)();
	void* (* alloc_large)();
	unsigned char** (* alloc_sarray)();
	short int (** (* alloc_barray)())[0x40];
	void* (* request_virt_sarray)();
	void* (* request_virt_barray)();
	void (* realize_virt_arrays)();
	unsigned char** (* access_virt_sarray)();
	short int (** (* access_virt_barray)())[0x40];
	void (* free_pool)();
	void (* self_destruct)();
	long int max_memory_to_use;
	long int max_alloc_chunk;
};

// "jpeg_memory_mgr_1"
struct jpeg_memory_mgr_1 __packed
{
	void* (* alloc_small)();
	void* (* alloc_large)();
	unsigned char** (* alloc_sarray)();
	short int (** (* alloc_barray)())[0x40];
	void* (* request_virt_sarray)();
	void* (* request_virt_barray)();
	void (* realize_virt_arrays)();
	unsigned char** (* access_virt_sarray)();
	short int (** (* access_virt_barray)())[0x40];
	void (* free_pool)();
	void (* self_destruct)();
	long int max_memory_to_use;
	long int max_alloc_chunk;
};

// "jpeg_progress_mgr"
struct jpeg_progress_mgr __packed
{
	void (* progress_monitor)();
	long int pass_counter;
	long int pass_limit;
	int completed_passes;
	int total_passes;
};

// "jpeg_progress_mgr_1"
struct jpeg_progress_mgr_1 __packed
{
	void (* progress_monitor)();
	long int pass_counter;
	long int pass_limit;
	int completed_passes;
	int total_passes;
};

// "jpeg_saved_marker_ptr"
typedef struct jpeg_marker_struct_1* jpeg_saved_marker_ptr;

// "jpeg_source_mgr"
struct jpeg_source_mgr __packed
{
	unsigned char const* next_input_byte;
	unsigned int bytes_in_buffer;
	void (* init_source)();
	int (* fill_input_buffer)();
	void (* skip_input_data)();
	int (* resync_to_restart)();
	void (* term_source)();
};

// "jpeg_source_mgr_1"
struct jpeg_source_mgr_1 __packed
{
	unsigned char const* next_input_byte;
	unsigned int bytes_in_buffer;
	void (* init_source)();
	int (* fill_input_buffer)();
	void (* skip_input_data)();
	int (* resync_to_restart)();
	void (* term_source)();
};

// "jpeg_upsampler"
struct jpeg_upsampler __packed
{
	void (* start_pass)();
	void (* upsample)();
	int need_context_rows;
};

// "jvirt_barray_ptr"
typedef void* jvirt_barray_ptr;

// "jvirt_sarray_ptr"
typedef void* jvirt_sarray_ptr;

// "size_t"
typedef uint32_t size_t;

// "size_t_1"
typedef unsigned int size_t_1;

// "timeval"
struct timeval
{
};

// "timezone"
struct timezone
{
};

// "timezone_1"
struct timezone_1 __packed
{
	int tz_minuteswest;
	int tz_dsttime;
};

// "uint32_t"
typedef unsigned int uint32_t;

// "uint64_t"
typedef long long unsigned int uint64_t;

// "uint8_t"
typedef unsigned char uint8_t;

// "va_list"
typedef void* va_list;

// "timeval_1"
struct timeval_1 __packed
{
	long int tv_sec;
	long int tv_usec;
};

// "MetadataPayload"
struct MetadataPayload __packed
{
	unsigned char* bytes;
	unsigned int size;
};

// "__jmp_buf_tag"
struct __jmp_buf_tag __packed
{
	int __jmpbuf[0x40];
	int __mask_was_saved;
	struct __packed
	{
		long unsigned int __val[0x20];
	} __saved_mask;
	__padding char _184[4];
};

// "_IO_FILE"
struct _IO_FILE
{
};

// "jpeg_error_mgr_1"
struct jpeg_error_mgr_1 __packed
{
	void (* error_exit)();
	void (* emit_message)();
	void (* output_message)();
	void (* format_message)();
	void (* reset_error_mgr)();
	int msg_code;
	union __packed
	{
		int i[0x8];
		char s[0x50];
	} msg_parm;
	int trace_level;
	long int num_warnings;
	char const* const* jpeg_message_table;
	int last_jpeg_message;
	char const* const* addon_message_table;
	int first_addon_message;
	int last_addon_message;
};

// "Elf32_Ident"
struct Elf32_Ident
{
	char signature[0x4];
	uint8_t file_class;
	uint8_t encoding;
	uint8_t version;
	uint8_t os;
	uint8_t abi_version;
	char pad[0x7];
};

// "_IO_FILE_1"
struct _IO_FILE_1
{
};

// "_IO_FILE_2"
struct _IO_FILE_2 __packed
{
	int _flags;
	char* _IO_read_ptr;
	char* _IO_read_end;
	char* _IO_read_base;
	char* _IO_write_base;
	char* _IO_write_ptr;
	char* _IO_write_end;
	char* _IO_buf_base;
	char* _IO_buf_end;
	char* _IO_save_base;
	char* _IO_backup_base;
	char* _IO_save_end;
	struct _IO_marker* _markers;
	struct _IO_FILE_2* _chain;
	int _fileno;
	int _flags2;
	long int _old_offset;
	short unsigned int _cur_column;
	signed char _vtable_offset;
	char _shortbuf[0x1];
	void* _lock;
	__padding char _4C[4];
	long long int _offset;
	void* __pad1;
	void* __pad2;
	void* __pad3;
	void* __pad4;
	unsigned int __pad5;
	int _mode;
	char _unused2[0x28];
};

// "jmp_buf_s"
struct jmp_buf_s
{
};

// "jmp_buf_1"
typedef struct __jmp_buf_tag jmp_buf_1[0x1];

// "FILE_2"
typedef struct _IO_FILE_2 FILE_2;

// "my_error_mgr"
struct my_error_mgr __packed
{
	struct jpeg_error_mgr_1 pub;
	__padding char _84[4];
	struct __jmp_buf_tag setjmp_buffer[0x1];
};

// "FILE"
typedef struct _IO_FILE FILE;

// "FILE_1"
typedef struct _IO_FILE_1 FILE_1;

// "Elf32_SectionHeader"
struct Elf32_SectionHeader
{
	uint32_t name;
	enum sh_type type;
	enum sh_flags flags;
	uint32_t address;
	uint32_t offset;
	uint32_t size;
	uint32_t link;
	uint32_t info;
	uint32_t align;
	uint32_t entry_size;
};

// "Elf32_ProgramHeader"
struct Elf32_ProgramHeader
{
	enum p_type type;
	uint32_t offset;
	uint32_t virtual_address;
	uint32_t physical_address;
	uint32_t file_size;
	uint32_t memory_size;
	enum p_flags flags;
	uint32_t align;
};

// "Elf32_Header"
struct Elf32_Header
{
	struct Elf32_Ident ident;
	enum e_type type;
	enum e_machine machine;
	uint32_t version;
	void (* entry)();
	uint32_t program_header_offset;
	uint32_t section_header_offset;
	uint32_t flags;
	uint16_t header_size;
	uint16_t program_header_size;
	uint16_t program_header_count;
	uint16_t section_header_size;
	uint16_t section_header_count;
	uint16_t string_table;
};

// "jmp_buf"
typedef struct jmp_buf_s jmp_buf[0x1];

// "Elf32_Dyn"
struct Elf32_Dyn
{
	enum e_dyn_tag d_tag;
	uint32_t d_val;
};

// "Stopwatch"
typedef struct timeval_1 Stopwatch;

// "Metadata"
struct Metadata __packed
{
	struct MetadataPayload exif;
	struct MetadataPayload iccp;
	struct MetadataPayload xmp;
};

// Globals

char const kICCPSignature[0xc];
struct { int marker; char const* signature; unsigned int signature_length; unsigned int storage_offset; } const kJPEGMetadataMap[0x3];

// Function signatures

int MetadataCopy(char const* metadata, unsigned int metadata_len, struct MetadataPayload* const payload);
int WebPPictureImportRGB(struct WebPPicture* picture, unsigned char const* rgb, int rgb_stride);
int jpeg_finish_decompress(struct jpeg_decompress_struct* cinfo);
int jpeg_read_header(struct jpeg_decompress_struct* cinfo, int require_image);
int jpeg_start_decompress(struct jpeg_decompress_struct* cinfo);
int32_t __fprintf_chk();
int32_t _setjmp(jmp_buf* __env);
int32_t jpeg_CreateDecompress(struct jpeg_decompress_struct* cinfo, int version, unsigned int structsize);
int32_t jpeg_destroy_decompress(struct jpeg_decompress_struct* cinfo);
int32_t malloc(size_t n);
int32_t memcmp(void const* s1, void const* s2, uint32_t n);
uint32_t fwrite(void const* ptr, uint32_t size, uint32_t count, FILE* stream);
unsigned char* ReadJPEG(struct _IO_FILE* in_file, struct WebPPicture* const pic, struct Metadata* const metadata);
unsigned int jpeg_read_scanlines(struct jpeg_decompress_struct* cinfo, unsigned char** scanlines, unsigned int max_lines);
void MetadataFree(struct Metadata* const metadata);
void __stack_chk_fail() __noreturn;
void free(void* ptr);
void jpeg_save_markers(struct jpeg_decompress_struct* cinfo, int marker_code, unsigned int length_limit);
void jpeg_std_error(struct jpeg_error_mgr* err);
void jpeg_stdio_src(struct jpeg_decompress_struct* cinfo, struct _IO_FILE* infile);
void qsort(void* base, uint32_t num, uint32_t size, int32_t (* compar)(void const*, void const*));
void* memcpy(void* dest, void const* src, uint32_t n);
void* memset(void* s, int32_t c, uint32_t n);

// CH Function Summary Typedefs
typedef struct jpeg_decompress_struct ch_jpeg_decompress_struct;
typedef struct jpeg_error_mgr ch_jpeg_error_mgr;
typedef struct WebPPicture ch_WebPPicture;
typedef struct Metadata ch_Metadata;
typedef struct MetadataPayload ch_MetadataPayload;
typedef struct _IO_FILE ch__IO_FILE;
